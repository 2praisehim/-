// 전화번호 목록
// 
// 2021-07-27

// <내 풀이>
#include <string>
#include <vector>

using namespace std;

bool solution(vector<string> phone_book) {
    bool answer = true;
    int cnt = 0;
    
    for(int i = 0; i < phone_book.size(); i++) { // i : 전체 전화번호부 개수만큼 돌림
        for(int j = i + 1; j < phone_book.size(); j++) { // j : 첫번째 기준으로 나머지 비교
            cnt = 0;
            for(int k = 0; k < phone_book[i].size(); k++) { // 전화번호부 하나씩 비교
                if(phone_book[i][k] == phone_book[j][k])
                    cnt++;
                
                if(k == phone_book[i].size() - 1 && cnt == phone_book[i].size())
                    answer = false;
            }
        }
    }
    return answer;
}

// <다른 풀이>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

bool solution(vector<string> phone_book) {
  sort(phone_book.begin(), phone_book.end());
  
  for(int i = 0; i < phone_book.size() - 1; i++)
  {
    if(phone_book[i] == phone_book[i+1].substr(0, phone_book[i].size()))
      return false;
  }
  return true;
}

/* 
삼중 포문을 사용하여 전화번호부의 크기가 큰 경우에서 시간 초과 에러가 발생하였다.
다른 풀이를 찾아보니 정렬을 통해 사전 순으로 배치하여 인접 원소만 비교하여 시간 단축을 했다.
이중 포문을 이용하여 캐릭터별 하나씩 비교하면 시간이 오래걸리니까 스트링 비교에 익숙해져야 할 것 같고 다음엔 해시 풀이도 해보겠다.
*/
